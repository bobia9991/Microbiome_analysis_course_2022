train.model_mod <- function (siamcat, method = c("lasso", "enet", "ridge", "lasso_ll", 
                              "ridge_ll", "randomForest"), stratify = TRUE, modsel.crit = list("auc"), 
          min.nonzero.coeff = 1, param.set = NULL, perform.fs = FALSE, 
          param.fs = list(thres.fs = 100, method.fs = "AUC", direction = "absolute"), 
          feature.type = "normalized", verbose = 1) 
{
    
    library(progress)
    
    if (verbose > 1) 
        message("+ starting train.model")
    s.time <- proc.time()[3]
    if (!feature.type %in% c("original", "filtered", "normalized")) {
        stop("Unrecognised feature type, exiting...\n")
    }
    if (feature.type == "original") {
        feat <- get.orig_feat.matrix(siamcat)
    }
    else if (feature.type == "filtered") {
        if (is.null(filt_feat(siamcat, verbose = 0))) {
            stop("Features have not yet been filtered, exiting...\n")
        }
        feat <- get.filt_feat.matrix(siamcat)
    }
    else if (feature.type == "normalized") {
        if (is.null(norm_feat(siamcat, verbose = 0))) {
            stop("Features have not yet been normalized, exiting...\n")
        }
        feat <- get.norm_feat.matrix(siamcat)
    }
    rownames(feat) <- make.names(rownames(feat))
    label <- label(siamcat)
    if (label$type == "TEST") {
        stop("Model can not be trained to SIAMCAT object with a TEST label.", 
             " Exiting...")
    }
    if (is.null(data_split(siamcat, verbose = 0))) {
        stop("SIAMCAT object needs a data split for model training! Exiting...")
    }
    data.split <- data_split(siamcat)
    if (!all(modsel.crit %in% c("auc", "f1", "acc", "pr", "auprc"))) {
        warning("Unkown model selection criterion... Defaulting to AU-ROC!\n")
        measure <- list(mlr::auc)
    }
    else {
        measure <- list()
    }
    if (verbose > 2) 
        message("+++ preparing selection measures")
    for (m in modsel.crit) {
        if (m == "auc") {
            measure[[length(measure) + 1]] <- mlr::auc
        }
        else if (m == "acc") {
            measure[[length(measure) + 1]] <- mlr::acc
        }
        else if (m == "f1") {
            measure[[length(measure) + 1]] <- mlr::f1
        }
        else if (m == "pr" || m == "auprc") {
            auprc <- makeMeasure(id = "auprc", minimize = FALSE, 
                                 best = 1, worst = 0, properties = c("classif", 
                                                                     "req.pred", "req.truth", "req.prob"), name = "Area under the Precision\n                Recall Curve", 
                                 fun = function(task, model, pred, feats, extra.args) {
                                     measureAUPRC(getPredictionProbabilities(pred), 
                                                  pred$data$truth, pred$task.desc$negative, 
                                                  pred$task.desc$positive)
                                 })
            measure[[length(measure) + 1]] <- auprc
        }
    }
    hyperpar.list <- list()
    models.list <- list()
    num.runs <- data.split$num.folds * data.split$num.resample
    bar <- 0
    if (verbose > 1) 
        message(paste("+ training", method, "models on", num.runs, 
                      "training sets"))
    if (verbose > 1 & perform.fs) {
        message("+ Performing feature selection ", "with following parameters:")
        for (i in seq_along(param.fs)) {
            message(paste0("    ", names(param.fs)[i], " = ", 
                           ifelse(is.null(param.fs[[i]]), "NULL", param.fs[[i]])))
        }
    }
    if (verbose == 1 || verbose == 2) 
        pb <- progress_bar$new(total = num.runs)
    for (fold in seq_len(data.split$num.folds)) {
        if (verbose > 2) 
            message(paste("+++ training on cv fold:", fold))
        for (resampling in seq_len(data.split$num.resample)) {
            if (verbose > 2) 
                message(paste("++++ repetition:", resampling))
            fold.name <- paste0("cv_fold", as.character(fold), 
                                "_rep", as.character(resampling))
            fold.exm.idx <- match(data.split$training.folds[[resampling]][[fold]], 
                                  names(label$label))
            label.fac <- factor(label$label, levels = sort(label$info))
            train.label <- label.fac[fold.exm.idx]
            data <- as.data.frame(t(feat)[fold.exm.idx, ])
            stopifnot(nrow(data) == length(train.label))
            stopifnot(all(rownames(data) == names(train.label)))
            if (perform.fs) {
                stopifnot(all(c("method.fs", "thres.fs", "direction") %in% 
                                  names(param.fs)))
                if (!param.fs$method.fs %in% c("Wilcoxon", "AUC", 
                                               "gFC")) {
                    stop("Unrecognised feature selection method...\n")
                }
                if (param.fs$method.fs == "Wilcoxon") {
                    stopifnot(param.fs$thres.fs < 1 && param.fs$thres.fs > 
                                  0)
                }
                else {
                    stopifnot(param.fs$thres.fs > 0)
                }
                
                # DEACTIVATED to allow less than 10 features when doing feature selection
                # stopifnot(param.fs$thres.fs < ncol(data))
                if (param.fs$method.fs == "Wilcoxon") {
                    assoc <- vapply(data, FUN = function(x, label) {
                        d <- data.frame(x = x, y = label)
                        t <- wilcox.test(x ~ y, data = d)
                        return(t$p.val)
                    }, FUN.VALUE = double(1), label = train.label)
                    data <- data[, which(assoc < param.fs$thres.fs)]
                }
                else if (param.fs$method.fs == "AUC") {
                    assoc <- vapply(data, FUN = SIAMCAT:::get.single.feat.AUC, 
                                    FUN.VALUE = double(1), label = train.label, 
                                    pos = max(label$info), neg = min(label$info))
                    if (param.fs$direction == "absolute") {
                        assoc[assoc < 0.5] <- 1 - assoc[assoc < 
                                                            0.5]
                    }
                    else if (param.fs$direction == "negative") {
                        assoc <- 1 - assoc
                    }
                    asso <- assoc[assoc > 0.5]
                    data <- data[, names(which(rank(-assoc) <= 
                                                   param.fs$thres.fs))]
                }
                else if (param.fs$method.fs == "gFC") {
                    assoc <- vapply(data, FUN = get.quantile.FC, 
                                    FUN.VALUE = double(1), label = train.label, 
                                    pos = max(label$info), neg = min(label$info))
                    if (param.fs$direction == "absolute") {
                        assoc <- abs(assoc)
                    }
                    else if (param.fs$direction == "negative") {
                        assoc <- -assoc
                    }
                    assoc <- assoc[assoc > 0]
                    data <- data[, names(which(rank(-assoc) <= 
                                                   param.fs$thres.fs))]
                }
                stopifnot(ncol(data) > 0)
                if (verbose > 2) {
                    message(paste0("++ retaining ", ncol(data), 
                                   " features after feature selection with ", 
                                   param.fs$method.fs, "-threshold ", param.fs$thres.fs))
                }
            }
            data$label <- train.label
            model <- SIAMCAT:::train.plm(data = data, method = method, 
                               measure = measure, min.nonzero.coeff = min.nonzero.coeff, 
                               param.set = param.set, neg.lab = min(label$info))
            bar <- bar + 1
            if (!all(model$feat.weights == 0)) {
                models.list[[bar]] <- model
            }
            else {
                warning("Model without any features selected!\n")
            }
            if (verbose == 1 || verbose == 2) 
                pb$tick()
        }
    }
    model_list(siamcat) <- list(models = models.list, model.type = method, 
                                feature.type = feature.type)
    e.time <- proc.time()[3]
    if (verbose > 1) 
        message(paste("+ finished train.model in", formatC(e.time - 
                                                               s.time, digits = 3), "s"))
    if (verbose == 1) 
        message(paste("Trained", method, "models successfully."))
    return(siamcat)
}

run_SIAMCAT_workflow <- function(siamcat, performFeatureSelection, file_prefix) {
    

    # TODO: thres.fs = 11 refers to the minimum number of features that should be selected

    if (!is.na(performFeatureSelection)) {
        siamcat <- train.model_mod(siamcat, method = methodCur, verbose = 2, 
                                   perform.fs = TRUE, 
                                   param.fs = list(thres.fs = performFeatureSelection, method.fs = "AUC", direction='absolute'))
    } else {
        siamcat <- train.model(siamcat, method = methodCur, verbose = 2, perform.fs = FALSE)
    }
    
    
    siamcat <- make.predictions(siamcat)
    siamcat <- evaluate.predictions(siamcat)    
    print(siamcat@eval_data$auroc)
    feature_weights(siamcat)

    model.evaluation.plot(siamcat, fn.plot = paste0(file_prefix, "_eval.plot.pdf"))

    model.interpretation.plot(siamcat, fn.plot = paste0(file_prefix, "_interpret.plot.pdf"),
                              #consens.thres = 0.5, # 0.01 for randomForest
                              #detect.lim = 1e-05,
                              #heatmap.type = 'zscore',
                              # limits = c(-10,10))
    )
    
    siamcat
}



add.meta <- function(x, n, method){
    x <- add.meta.pred(x, pred.names = n, verbose=3)
    x <- train.model(x, method= method, verbose=2, perform.fs = FALSE)
    x <- make.predictions(x)
    x <- evaluate.predictions(x)
    return(x)
}
